\documentclass{article}

\usepackage[letterpaper,top=2cm,bottom=2cm,left=2cm,right=2cm,marginparwidth=1.75cm]{geometry}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage[parfill]{parskip}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\pdfpagewidth=8.5in
\pdfpageheight=11in


\def\tricolfig#1{\includegraphics[width=2.2in]{#1}}
\def\triplecolfig#1{\includegraphics[width=0.32\textwidth]{#1}}
\def\smallcolfig#1{\includegraphics[width=2.0in]{#1}}
\def\smallercolfig#1{\includegraphics[width=0.75\columnwidth]{#1}}
\def\mediumcolfig#1{\includegraphics[width=0.9\columnwidth]{#1}}
\def\colfig#1{\includegraphics[width=\columnwidth]{#1}}
\def\pagefig#1{\includegraphics[width=0.75\textwidth]{#1}}
\def\suspcolfig#1{\includegraphics[width=2.0in]{#1}}
\def\perfcolfig#1{\smallercolfig{#1}}



\def\crcd{compiler-runtime co-design}
\def\ALL{allocation}
\def\DALL{deallocation}
\def\ALLS{allocations}
\def\DALLS{deallocations}
\def\DWS{dynamic memory working set size}



\title{Compiler and Runtime Support for Functions-as-a-Service (FaaS)}
\date{}
\author{Souradip Ghosh, 15-849, Fall 2021}

\begin{document}
\maketitle

\section{Abstract}
Functions-as-a-Service (FaaS) are rapidly growing in popularity and 
complexity among cloud service provides as users look to take 
advantage of cloud resources on-demand and focus on computation
at a finer grain. FaaS instances are characteristically short-lived
and often dominated by communication and cold-start overheads compared
to typical monolithic applications. At the same time, FaaS instances
are requiring more resources, especially memory, to operate. Although
many works have approached these issues with scheduling optimizations,
hardware accelerators, and other techniques, very few have examined
\textit{compiler} support and \textit{\crcd} for FaaS. This paper presents 
a \crcd\ consisting of static analyses, profiling, and a custom memory 
allocator controlled by the compiler and runtime to better understand 
and optimize \textit{dynamic memory usage} for small FaaS workloads.

\section{Introduction/Background}

\section{Design}
The design of the system consists of three major components : 1) a \textit{profiler},
2) \textit{static analyses} in the compiler, and 3) a \textit{custom memory allocator}.
The first and third components consist of compiler instrumentation coupled with an 
integrated runtime. All analyses and transformations operate on the \textit{intermediate 
representation} (IR) of the compiler, where standard compiler optimizations are performed.
These components are described in the following subsections in detail. 

\begin{figure}
    \centerline{\pagefig{figs/sys.pdf}}
    \caption{System overview and compilation pipeline. }  
	\label{fig:sys}
\end{figure}

An overview of the system and compilation pipeline is show in Figure~\ref{fig:sys}. The 
first pass over an example workload (\texttt{app.c}) consists of static analyses and 
profiling. The second pass over \texttt{app.c} instruments the program with the custom
allocator using the results from the static analyses (and optionally the profiler). The
outputs from this compilation pipeline include an instrumented application (\texttt{app.exe})
and statistics about \DWS\.

\subsection{Profiler}
The profiler has the goal of understanding information about dynamic memory \ALLS\ and 
\DALLS\ during execution (for instance, the number of \ALLS\, \DWS\, common \ALL 
sizes, etc.) as well as standard information about the "hotness" of functions and
loops at runtime. Using this data, the profiler can inform the compiler during 
instrumentation in the second pass over the application (see \ref{ca}). It can also 
inform the user with a better estimate of memory usage for a future FaaS instance or 
function invocation.

The profiler tracks all \ALLS and \DALLS of some workload, $W$, at runtime. This is 
accomplished by instrumenting all explicit dynamic memory \ALL\ and \DALL\ function 
calls in the IR for $W$ with \textit{callback} functions to a profiler runtime.
Two callbacks, \texttt{TrackAllocation(ptr, size)} and \texttt{TrackDeallocation(ptr)}, are 
sufficient to achieve all tracking. \texttt{TrackAllocation} takes a pointer to an allocation (\texttt{ptr}) and 
the size of the allocation (\texttt{size}) as inputs and records the pair in a table in the 
profiler's runtime. \texttt{TrackDeallocation} simply takes a pointer to an allocation (\texttt{ptr}) as
input and removes the entry from the profiler runtime's table. 

While $W$ runs, the profiler tracks each change \DWS\ over its entire execution. Using 
this information, the profiler calculates maximum and average \DWS\ for $W$ and outputs
the data to the user and to the compiler for future use.

\subsection{Static Analyses}

\subsection{Custom Allocator}

\section{Implementation}

\section{Evaluation}

\section{Future Work}

\section{Conclusion}

\bibliographystyle{plain}
\bibliography{sample}

\end{document}
